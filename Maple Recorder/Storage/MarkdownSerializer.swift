import Foundation

enum MarkdownSerializer {

    // MARK: - Serialize

    static func serialize(_ recording: MapleRecording) -> String {
        var output = "# \(recording.title)\n"

        // Meeting Overview
        if !recording.summary.isEmpty {
            output += "\n## Meeting Overview\n\n"
            output += "\(recording.summary)\n"
        }

        // Details
        output += "\n## Details\n\n"
        output += "- **Date**: \(formattedDate(recording.createdAt))\n"
        output += "- **Duration**: \(formattedDuration(recording.duration))\n"
        output += "- **Speakers**: \(recording.speakers.count)\n"

        // Tags
        if !recording.tags.isEmpty {
            output += "\n## Tags\n\n"
            output += recording.tags.map { "#\($0)" }.joined(separator: " ") + "\n"
        }

        // JSON metadata block (source of truth)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]

        if let jsonData = try? encoder.encode(recording.metadata),
           let jsonString = String(data: jsonData, encoding: .utf8) {
            output += "\n~~~json\n\(jsonString)\n~~~\n"
        }

        // Transcript
        if !recording.transcript.isEmpty {
            output += "\n## Transcript\n\n"
            for segment in recording.transcript {
                let speakerName = recording.speakers.first(where: { $0.id == segment.speakerId })?.displayName ?? segment.speakerId
                output += "**\(speakerName)** (\(formattedTimestamp(segment.start))): \(segment.text)\n\n"
            }
        }

        // AI Insights (prompt results)
        if !recording.promptResults.isEmpty {
            output += "## AI Insights\n"
            for result in recording.promptResults {
                let providerName = displayName(for: result.llmProvider)
                output += "\n### \(result.promptName)\n\n"
                output += "*Generated by \"\(result.promptName)\" prompt â€” \(providerName)*\n\n"
                output += "\(result.result)\n"
            }
        }

        return output
    }

    // MARK: - Deserialize

    static func deserialize(_ markdown: String) -> MapleRecording? {
        let lines = markdown.components(separatedBy: "\n")
        guard !lines.isEmpty else { return nil }

        // Parse title from H1
        guard let titleLine = lines.first(where: { $0.hasPrefix("# ") }) else {
            return nil
        }
        let title = String(titleLine.dropFirst(2))

        // Find the JSON block
        let jsonStartMarkers = ["~~~json", "```json"]
        let jsonEndMarkers = ["~~~", "```"]

        var jsonStartIndex: Int?
        var jsonEndIndex: Int?
        var usedEndMarker = "~~~"

        for (i, line) in lines.enumerated() {
            let trimmed = line.trimmingCharacters(in: .whitespaces)
            if jsonStartIndex == nil {
                for marker in jsonStartMarkers {
                    if trimmed == marker {
                        jsonStartIndex = i
                        usedEndMarker = String(marker.prefix(3))
                        break
                    }
                }
            } else if jsonEndIndex == nil {
                for marker in jsonEndMarkers where marker == usedEndMarker {
                    if trimmed == marker {
                        jsonEndIndex = i
                        break
                    }
                }
            }
        }

        guard let start = jsonStartIndex, let end = jsonEndIndex, end > start + 1 else {
            return nil
        }

        // Extract summary from ## Meeting Overview section
        var summary = ""
        if let overviewIndex = lines.firstIndex(where: { $0.hasPrefix("## Meeting Overview") }) {
            // Collect lines from after heading until next ## heading or JSON block
            let contentStart = overviewIndex + 1
            var contentLines: [String] = []
            for i in contentStart..<lines.count {
                if lines[i].hasPrefix("## ") { break }
                if lines[i].trimmingCharacters(in: .whitespaces) == "~~~json" || lines[i].trimmingCharacters(in: .whitespaces) == "```json" { break }
                contentLines.append(lines[i])
            }
            summary = contentLines.joined(separator: "\n").trimmingCharacters(in: .whitespacesAndNewlines)
        }

        // Decode JSON metadata
        let jsonLines = lines[(start + 1)..<end]
        let jsonString = jsonLines.joined(separator: "\n")
        guard let jsonData = jsonString.data(using: .utf8) else { return nil }

        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601

        guard let metadata = try? decoder.decode(MapleRecording.MetadataJSON.self, from: jsonData) else {
            return nil
        }

        return MapleRecording(title: title, summary: summary, metadata: metadata)
    }

    // MARK: - Formatting Helpers

    static func formattedDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, yyyy 'at' h:mm a"
        return formatter.string(from: date)
    }

    static func formattedDuration(_ duration: TimeInterval) -> String {
        let totalSeconds = Int(duration)
        let hours = totalSeconds / 3600
        let minutes = (totalSeconds % 3600) / 60
        let seconds = totalSeconds % 60
        if hours > 0 {
            return String(format: "%d:%02d:%02d", hours, minutes, seconds)
        }
        return String(format: "%d:%02d", minutes, seconds)
    }

    static func formattedTimestamp(_ time: TimeInterval) -> String {
        let totalSeconds = Int(time)
        let minutes = totalSeconds / 60
        let seconds = totalSeconds % 60
        return String(format: "%d:%02d", minutes, seconds)
    }

    // MARK: - Helpers

    private static func displayName(for provider: LLMProvider) -> String {
        switch provider {
        case .appleFoundationModels: "Apple Foundation Models"
        case .claude: "Claude"
        case .openai: "OpenAI"
        case .none: "None"
        }
    }
}
