import Foundation

enum MarkdownSerializer {

    // MARK: - Serialize

    static func serialize(_ recording: MapleRecording) -> String {
        var output = "# \(recording.title)\n\n"

        if !recording.summary.isEmpty {
            output += "\(recording.summary)\n\n"
        }

        // JSON metadata block
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]

        if let jsonData = try? encoder.encode(recording.metadata),
           let jsonString = String(data: jsonData, encoding: .utf8) {
            output += "~~~json\n\(jsonString)\n~~~\n"
        }

        // Prompt result sections
        for result in recording.promptResults {
            let providerName = displayName(for: result.llmProvider)
            output += "\n## \(result.promptName)\n\n"
            output += "*Generated by \"\(result.promptName)\" prompt â€” \(providerName)*\n\n"
            output += "\(result.result)\n"
        }

        return output
    }

    // MARK: - Deserialize

    static func deserialize(_ markdown: String) -> MapleRecording? {
        let lines = markdown.components(separatedBy: "\n")
        guard !lines.isEmpty else { return nil }

        // Parse title from H1
        guard let titleLine = lines.first(where: { $0.hasPrefix("# ") }) else {
            return nil
        }
        let title = String(titleLine.dropFirst(2))

        // Find the JSON block
        let jsonStartMarkers = ["~~~json", "```json"]
        let jsonEndMarkers = ["~~~", "```"]

        var jsonStartIndex: Int?
        var jsonEndIndex: Int?
        var usedEndMarker = "~~~"

        for (i, line) in lines.enumerated() {
            let trimmed = line.trimmingCharacters(in: .whitespaces)
            if jsonStartIndex == nil {
                for marker in jsonStartMarkers {
                    if trimmed == marker {
                        jsonStartIndex = i
                        usedEndMarker = String(marker.prefix(3))
                        break
                    }
                }
            } else if jsonEndIndex == nil {
                for marker in jsonEndMarkers where marker == usedEndMarker {
                    if trimmed == marker {
                        jsonEndIndex = i
                        break
                    }
                }
            }
        }

        guard let start = jsonStartIndex, let end = jsonEndIndex, end > start + 1 else {
            return nil
        }

        // Extract summary: lines between title and JSON block
        let titleLineIndex = lines.firstIndex(of: titleLine) ?? 0
        let summaryLines = lines[(titleLineIndex + 1)..<start]
        let summary = summaryLines
            .joined(separator: "\n")
            .trimmingCharacters(in: .whitespacesAndNewlines)

        // Decode JSON metadata
        let jsonLines = lines[(start + 1)..<end]
        let jsonString = jsonLines.joined(separator: "\n")
        guard let jsonData = jsonString.data(using: .utf8) else { return nil }

        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601

        guard let metadata = try? decoder.decode(MapleRecording.MetadataJSON.self, from: jsonData) else {
            return nil
        }

        return MapleRecording(title: title, summary: summary, metadata: metadata)
    }

    // MARK: - Helpers

    private static func displayName(for provider: LLMProvider) -> String {
        switch provider {
        case .appleFoundationModels: "Apple Foundation Models"
        case .claude: "Claude"
        case .openai: "OpenAI"
        case .none: "None"
        }
    }
}
